# -*- coding: utf-8 -*-
"""Funções.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HFURn89BUKBmrh0zh7Yfy_Rfk2Jcgkrk
"""

# Código 01
# Reescreva o código abaixo removendo o uso desnecessário de switch/case:

import java.util.Map;
import java.util.HashMap;

public class Pedido {
    private double valorTotal;
    private String tipoCliente; // Pode ser "COMUM", "VIP" ou "FUNCIONARIO"

    // Map para armazenar os descontos por tipo de cliente
    private static final Map<String, Double> DESCONTOS = new HashMap<>();

    static {
        DESCONTOS.put("COMUM", 0.05);      // 5% de desconto
        DESCONTOS.put("VIP", 0.10);        // 10% de desconto
        DESCONTOS.put("FUNCIONARIO", 0.20); // 20% de desconto
    }

    public Pedido(double valorTotal, String tipoCliente) {
        this.valorTotal = valorTotal;
        this.tipoCliente = tipoCliente;
    }

    // Método refatorado sem switch/case
    public double calcularDesconto() {
        double desconto = DESCONTOS.getOrDefault(tipoCliente, 0.0);
        return valorTotal * (1 - desconto);
    }

    // Método para exibir o resumo do pedido
    public void exibirResumo() {
        System.out.println("Tipo de Cliente: " + tipoCliente);
        System.out.println("Valor Original: R$" + valorTotal);
        System.out.println("Valor com Desconto: R$" + calcularDesconto());
    }

    public static void main(String[] args) {
        Pedido pedido1 = new Pedido(100.0, "VIP");
        pedido1.exibirResumo();
    }
}

# Código 02
# Reescreva o código abaixo removendo as assinaturas de métodos com um número excessivo de parâmetros:

// Classe para representar as estatísticas de um time
class EstatisticasTime {
    private String nome;
    private int gols;
    private int posseBola;
    private int chutes;
    private int faltas;
    private int cartoesAmarelos;
    private int cartoesVermelhos;

    public EstatisticasTime(String nome, int gols, int posseBola, int chutes,
                           int faltas, int cartoesAmarelos, int cartoesVermelhos) {
        this.nome = nome;
        this.gols = gols;
        this.posseBola = posseBola;
        this.chutes = chutes;
        this.faltas = faltas;
        this.cartoesAmarelos = cartoesAmarelos;
        this.cartoesVermelhos = cartoesVermelhos;
    }

    // Getters
    public String getNome() { return nome; }
    public int getGols() { return gols; }
    public int getPosseBola() { return posseBola; }
    public int getChutes() { return chutes; }
    public int getFaltas() { return faltas; }
    public int getCartoesAmarelos() { return cartoesAmarelos; }
    public int getCartoesVermelhos() { return cartoesVermelhos; }
    public int getTotalCartoes() { return cartoesAmarelos + cartoesVermelhos; }
}

// Classe para representar uma partida
class Partida {
    private EstatisticasTime timeCasa;
    private EstatisticasTime timeVisitante;

    public Partida(EstatisticasTime timeCasa, EstatisticasTime timeVisitante) {
        this.timeCasa = timeCasa;
        this.timeVisitante = timeVisitante;
    }

    public EstatisticasTime getTimeCasa() { return timeCasa; }
    public EstatisticasTime getTimeVisitante() { return timeVisitante; }

    public String getVencedor() {
        if (timeCasa.getGols() > timeVisitante.getGols()) {
            return timeCasa.getNome();
        } else if (timeCasa.getGols() < timeVisitante.getGols()) {
            return timeVisitante.getNome();
        } else {
            return "Empate";
        }
    }

    public int getTotalChutes() {
        return timeCasa.getChutes() + timeVisitante.getChutes();
    }

    public int getTotalFaltas() {
        return timeCasa.getFaltas() + timeVisitante.getFaltas();
    }

    public int getTotalCartoes() {
        return timeCasa.getTotalCartoes() + timeVisitante.getTotalCartoes();
    }
}

public class GerenciadorPartida {

    public void registrarPartida(Partida partida) {
        EstatisticasTime casa = partida.getTimeCasa();
        EstatisticasTime visitante = partida.getTimeVisitante();

        System.out.println("Partida Registrada:");
        System.out.println(casa.getNome() + " " + casa.getGols() + " x " +
                          visitante.getGols() + " " + visitante.getNome());
        System.out.println("Posse de Bola: " + casa.getPosseBola() + "% - " +
                          visitante.getPosseBola() + "%");
        System.out.println("Chutes: " + casa.getChutes() + " - " + visitante.getChutes());
        System.out.println("Faltas: " + casa.getFaltas() + " - " + visitante.getFaltas());
        System.out.println("Cartões Amarelos: " + casa.getCartoesAmarelos() + " - " +
                          visitante.getCartoesAmarelos());
        System.out.println("Cartões Vermelhos: " + casa.getCartoesVermelhos() + " - " +
                          visitante.getCartoesVermelhos());
    }

    public void gerarRelatorio(Partida partida) {
        System.out.println("=== Relatório da Partida ===");
        System.out.println("Vencedor: " + partida.getVencedor());
        System.out.println("Posse de Bola: " + partida.getTimeCasa().getPosseBola() + "% - " +
                          partida.getTimeVisitante().getPosseBola() + "%");
        System.out.println("Total de Chutes: " + partida.getTotalChutes());
        System.out.println("Total de Faltas: " + partida.getTotalFaltas());
        System.out.println("Total de Cartões: " + partida.getTotalCartoes());
    }

    public static void main(String[] args) {
        GerenciadorPartida gerenciador = new GerenciadorPartida();

        // Criando as estatísticas dos times
        EstatisticasTime timeA = new EstatisticasTime("Time A", 2, 55, 10, 15, 3, 1);
        EstatisticasTime timeB = new EstatisticasTime("Time B", 1, 45, 8, 12, 2, 0);

        // Criando a partida
        Partida partida = new Partida(timeA, timeB);

        // Usando os métodos refatorados
        gerenciador.registrarPartida(partida);
        gerenciador.gerarRelatorio(partida);
    }
}

# Código 03
# Reescreva o código abaixo sem utilizar parâmetros booleanos nas funções:

// Enum para representar o status do filme
enum StatusFilme {
    DISPONIVEL,
    INDISPONIVEL
}

public class FilmeService {

    // Métodos específicos para listagem - mais expressivos
    public void listarFilmesDisponiveis() {
        System.out.println("Listando apenas filmes disponíveis para locação...");
    }

    public void listarTodosFilmes() {
        System.out.println("Listando todos os filmes do catálogo...");
    }

    // Métodos específicos para atualização de status
    public void marcarFilmeComoDisponivel(String titulo) {
        System.out.println("O filme \"" + titulo + "\" agora está disponível para locação.");
    }

    public void marcarFilmeComoIndisponivel(String titulo) {
        System.out.println("O filme \"" + titulo + "\" foi marcado como indisponível.");
    }

    // Alternativa usando enum (mais flexível para futuras expansões)
    public void atualizarStatusFilme(String titulo, StatusFilme status) {
        switch (status) {
            case DISPONIVEL:
                marcarFilmeComoDisponivel(titulo);
                break;
            case INDISPONIVEL:
                marcarFilmeComoIndisponivel(titulo);
                break;
        }
    }

    // Método alternativo usando Strategy Pattern (para casos mais complexos)
    public void processarFilme(String titulo, OperacaoFilme operacao) {
        operacao.executar(titulo);
    }

    public static void main(String[] args) {
        FilmeService service = new FilmeService();

        // Usando métodos específicos - muito mais claro
        service.listarFilmesDisponiveis();
        service.listarTodosFilmes();
        service.marcarFilmeComoDisponivel("Inception");
        service.marcarFilmeComoIndisponivel("Matrix");

        System.out.println("\n--- Usando enum ---");
        // Usando enum
        service.atualizarStatusFilme("Interstellar", StatusFilme.DISPONIVEL);
        service.atualizarStatusFilme("Avatar", StatusFilme.INDISPONIVEL);

        System.out.println("\n--- Usando Strategy Pattern ---");
        // Usando Strategy Pattern com lambdas
        service.processarFilme("Dune", titulo ->
            System.out.println("O filme \"" + titulo + "\" agora está disponível para locação."));
        service.processarFilme("Blade Runner", titulo ->
            System.out.println("O filme \"" + titulo + "\" foi marcado como indisponível."));
    }
}

# Código 04
# Reescreva o código abaixo resolvendo um problema de imulatibilidade que causa um problema com o preço final do produto quando usado mais de uma vez:

// Classe Produto imutável
class Produto {
    private final String nome;
    private final double preco;

    public Produto(String nome, double preco) {
        this.nome = nome;
        this.preco = preco;
    }

    // Getters para acessar os dados
    public String getNome() {
        return nome;
    }

    public double getPreco() {
        return preco;
    }

    // Método que retorna um novo produto com desconto aplicado
    // Não modifica o produto original
    public Produto aplicarDesconto(double desconto) {
        double novoPreco = Math.max(0, this.preco - desconto);
        return new Produto(this.nome, novoPreco);
    }

    // Método para criar cópia do produto
    public Produto copiar() {
        return new Produto(this.nome, this.preco);
    }

    @Override
    public String toString() {
        return "Produto{nome='" + nome + "', preco=" + preco + "}";
    }
}

// Classe para representar um item no carrinho (produto + desconto aplicado)
class ItemCarrinho {
    private final Produto produtoOriginal;
    private final Produto produtoComDesconto;
    private final double descontoAplicado;

    public ItemCarrinho(Produto produto) {
        this.produtoOriginal = produto;
        this.produtoComDesconto = produto;
        this.descontoAplicado = 0.0;
    }

    private ItemCarrinho(Produto produtoOriginal, Produto produtoComDesconto, double descontoAplicado) {
        this.produtoOriginal = produtoOriginal;
        this.produtoComDesconto = produtoComDesconto;
        this.descontoAplicado = descontoAplicado;
    }

    public ItemCarrinho aplicarDesconto(double desconto) {
        Produto novoProdutoComDesconto = this.produtoComDesconto.aplicarDesconto(desconto);
        return new ItemCarrinho(this.produtoOriginal, novoProdutoComDesconto, this.descontoAplicado + desconto);
    }

    public Produto getProdutoOriginal() {
        return produtoOriginal;
    }

    public Produto getProdutoComDesconto() {
        return produtoComDesconto;
    }

    public double getDescontoAplicado() {
        return descontoAplicado;
    }
}

class CarrinhoDeCompras {
    private ItemCarrinho item;

    public CarrinhoDeCompras(Produto produto) {
        this.item = new ItemCarrinho(produto);
    }

    public void adicionarProdutoAoCarrinho(Produto novoProduto) {
        this.item = new ItemCarrinho(novoProduto);
    }

    public void finalizarCompra() {
        // Aplica desconto criando um novo item, sem modificar o produto original
        this.item = this.item.aplicarDesconto(10.0);
        System.out.println("Compra finalizada com desconto aplicado!");
    }

    public void mostrarDetalhes() {
        Produto original = item.getProdutoOriginal();
        Produto comDesconto = item.getProdutoComDesconto();

        System.out.println("=== Detalhes do Carrinho ===");
        System.out.println("Produto: " + original.getNome());
        System.out.println("Preço Original: R$" + original.getPreco());
        System.out.println("Desconto Aplicado: R$" + item.getDescontoAplicado());
        System.out.println("Preço Final: R$" + comDesconto.getPreco());
    }

    public Produto getProdutoOriginal() {
        return item.getProdutoOriginal();
    }
}

public class Main {
    public static void main(String[] args) {
        // Criando produtos
        Produto produto1 = new Produto("Laptop", 1500.00);
        Produto produto2 = new Produto("Smartphone", 1200.00);

        System.out.println("=== Demonstração do Problema Resolvido ===");

        // Primeira compra
        System.out.println("\n--- Primeira Compra ---");
        CarrinhoDeCompras carrinho1 = new CarrinhoDeCompras(produto2);
        carrinho1.finalizarCompra();
        carrinho1.mostrarDetalhes();

        // Segunda compra com o mesmo produto - preço original mantido
        System.out.println("\n--- Segunda Compra (mesmo produto) ---");
        CarrinhoDeCompras carrinho2 = new CarrinhoDeCompras(produto2);
        carrinho2.finalizarCompra();
        carrinho2.mostrarDetalhes();

        // Verificando que o produto original não foi modificado
        System.out.println("\n--- Verificação do Produto Original ---");
        System.out.println("Produto original: " + produto2);

        // Demonstrando que podemos aplicar diferentes descontos
        System.out.println("\n--- Testando Diferentes Descontos ---");
        CarrinhoDeCompras carrinho3 = new CarrinhoDeCompras(produto1);
        carrinho3.finalizarCompra(); // Desconto de R$10
        carrinho3.mostrarDetalhes();

        // Produto original continua inalterado
        System.out.println("Produto1 original: " + produto1);
    }
}

# Código 05
# Reescreva o código abaixo de forma a métodos com funcionamento muito parecido.

// Enum para representar os diferentes personagens
enum TipoPersonagem {
    JOGADOR("Jogador"),
    INIMIGO("Inimigo");

    private final String nome;

    TipoPersonagem(String nome) {
        this.nome = nome;
    }

    public String getNome() {
        return nome;
    }
}

// Classe para representar um personagem no jogo
class Personagem {
    private final TipoPersonagem tipo;
    private int vida;
    private final int vidaMaxima;

    public Personagem(TipoPersonagem tipo, int vidaInicial) {
        this.tipo = tipo;
        this.vida = vidaInicial;
        this.vidaMaxima = vidaInicial;
    }

    public void receberDano(int dano) {
        this.vida = Math.max(0, this.vida - dano);
    }

    public boolean estaVivo() {
        return vida > 0;
    }

    public TipoPersonagem getTipo() {
        return tipo;
    }

    public int getVida() {
        return vida;
    }

    public int getVidaMaxima() {
        return vidaMaxima;
    }

    public String getNome() {
        return tipo.getNome();
    }
}

public class Jogo {
    private Personagem jogador;
    private Personagem inimigo;

    public Jogo(int vidaJogador, int vidaInimigo) {
        this.jogador = new Personagem(TipoPersonagem.JOGADOR, vidaJogador);
        this.inimigo = new Personagem(TipoPersonagem.INIMIGO, vidaInimigo);
    }

    // Método unificado que substitui atacarJogador e atacarInimigo
    public void atacar(TipoPersonagem alvo, int dano) {
        Personagem personagem = obterPersonagem(alvo);
        personagem.receberDano(dano);

        if (!personagem.estaVivo()) {
            System.out.println(personagem.getNome() + " perdeu!");
        } else {
            System.out.println("Vida do " + personagem.getNome() + ": " + personagem.getVida());
        }
    }

    // Métodos de conveniência que mantêm a interface original (opcional)
    public void atacarJogador(int dano) {
        atacar(TipoPersonagem.JOGADOR, dano);
    }

    public void atacarInimigo(int dano) {
        atacar(TipoPersonagem.INIMIGO, dano);
    }

    // Método auxiliar para obter o personagem correto
    private Personagem obterPersonagem(TipoPersonagem tipo) {
        return tipo == TipoPersonagem.JOGADOR ? jogador : inimigo;
    }

    // Getters refatorados
    public int getVida(TipoPersonagem tipo) {
        return obterPersonagem(tipo).getVida();
    }

    // Métodos de conveniência para manter compatibilidade
    public int getVidaJogador() {
        return getVida(TipoPersonagem.JOGADOR);
    }

    public int getVidaInimigo() {
        return getVida(TipoPersonagem.INIMIGO);
    }

    // Métodos adicionais úteis
    public boolean jogoTerminado() {
        return !jogador.estaVivo() || !inimigo.estaVivo();
    }

    public Personagem getVencedor() {
        if (!jogoTerminado()) {
            return null;
        }
        return jogador.estaVivo() ? jogador : inimigo;
    }

    public void mostrarStatus() {
        System.out.println("=== Status do Jogo ===");
        System.out.println(jogador.getNome() + ": " + jogador.getVida() + "/" + jogador.getVidaMaxima());
        System.out.println(inimigo.getNome() + ": " + inimigo.getVida() + "/" + inimigo.getVidaMaxima());

        if (jogoTerminado()) {
            Personagem vencedor = getVencedor();
            System.out.println("Vencedor: " + (vencedor != null ? vencedor.getNome() : "Empate"));
        }
    }

    // Classe para demonstrar o uso
    public static void main(String[] args) {
        Jogo jogo = new Jogo(100, 80);

        System.out.println("=== Início do Jogo ===");
        jogo.mostrarStatus();

        System.out.println("\n=== Usando métodos unificados ===");
        jogo.atacar(TipoPersonagem.INIMIGO, 30);
        jogo.atacar(TipoPersonagem.JOGADOR, 25);

        System.out.println("\n=== Usando métodos de conveniência ===");
        jogo.atacarInimigo(50);
        jogo.atacarJogador(20);

        System.out.println("\n=== Status Final ===");
        jogo.mostrarStatus();

        System.out.println("\n=== Testando getters unificados ===");
        System.out.println("Vida do Jogador: " + jogo.getVida(TipoPersonagem.JOGADOR));
        System.out.println("Vida do Inimigo: " + jogo.getVida(TipoPersonagem.INIMIGO));
    }
}